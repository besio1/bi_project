---
title: "Analysis of planAttributes.csv"
author: "Omar Besic und Musab Elkour" 
date: "23 Mai 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
### Wer?
Das **"Centers for Medicare & Medicaid Services (CMS) Center for Consumer Information & Insurance Oversight (CCIIO)** veröffentlicht sogenannte Exchange PUFs, um Transparenz und Zugang über Qualified Health Plans (QHPs) und Stand-alone Dental Plans (SADPs) zu schaffen. Diese werden Einzelpersonen und Kleinunternehmen über die Krankenversicherungsbörse angeboten.

***Wir behandeln in diesem Bericht das "Planattribute" - PUF***

Der Planattribute - PUF enthält unter Anderem Daten über maximale Selbstbehalte oder"Health Savings Accounts" der amerikanischen Bürger. Diese werden anonym auf Bundesebene geteilt und durch die jeweiligen Herausgeber der Versicherungen erfasst.

### Vorgehensweise 
1) Kontextanalyse der Daten
2) Kaggle Account erstellt + Daten extrahiert
3) Interessante Datensätze für die Auswertung herausgesucht
4) Gewählte Datensätze bereinigt
5) Bereinigte Datensätze manipuliert
5) Erstellen des Reports in RMarkdown

```{r,include=FALSE, echo=FALSE}
library(ggplot2)
library(readr)
library(dplyr) 
library(choroplethr)
library(extrafont)
library(extrafontdb)
library(RColorBrewer)
library(scales)
library(gridExtra)
library(choroplethrMaps)
library(knitr)
library(kableExtra)
```

### Der Dataset - Ausschnitt des Headers
Insgesamt gibt es 179 Kolonnen. Untenstehend wird ein Ausschnitt der vorhandenen Kolonnen gezeigt. Die Rot markierten Zeilen (entspricht im planAttributes.csv den Spalten) werden in diesem Bericht eingehender analysiert.

```{r, echo=FALSE}
planAttributes <- read.csv("PlanAttributes.csv", stringsAsFactors = FALSE)

planAttributesColumns <- as_tibble(planAttributes)
planAttributesColumns <- planAttributesColumns %>% select(110:130,150:165)


names(planAttributesColumns) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
                , fixed_thead = list(enabled = T, background = "dark"))  %>%
  row_spec(cbind(12,31), bold = T, color = "white", background = "#D7261E")
```

### TEHBInnTier1FamilyMOOP
**EHB = Essential Health Benefits**
**Moop = Maximum out of pocket**

Der maximale Selbstbehalt den man im Rahmen des Gesundheitsplans zahlen muss (für eine Familie). 

Wir berechnen untenstehend


```{r, echo=FALSE}

# import data with help of the readr package and reads comma delimited files
planAttributes <- read.csv("PlanAttributes.csv", stringsAsFactors = FALSE)

x <- knitr::kable(planAttributes[5,158:160], "html")
column_spec(x, 1:2, width = "20em", bold = TRUE, italic = TRUE)

# Maximum Out of Pocket for Medical and Drug EHB Benefits (Total),
# In Network (Tier 1), Family
# The max out of pocket is the amount of money that the family would 
# have to pay before the insurance covers everything 100%
# Give me the TEHBInnTier1FamilyMOOP column just for a short glimpse
planAttributes <- planAttributes %>% select(TEHBInnTier1FamilyMOOP)

# replace all "," with " " in TEHBInnTier1FamilyMOOP
# as example: given = $12,600 BUT wanted = $12600
planAttributes$TEHBInnTier1FamilyMOOP<- gsub(',', '', planAttributes$TEHBInnTier1FamilyMOOP)

# replace all "\\$" with " " in TEHBInnTier1FamilyMOOP
# as example: given = $12600 BUT wanted = 12600
planAttributes$TEHBInnTier1FamilyMOOP<- gsub('\\$', '', planAttributes$TEHBInnTier1FamilyMOOP)

# assign (and convert to numeric) the maximum out of pocket column to planAttributes$moop
planAttributes$moop<- as.numeric(planAttributes$TEHBInnTier1FamilyMOOP)

# fill the blank cells with 0
planAttributes$moop[is.na(planAttributes$moop)] <- 0

# plot histogram of moop
ggplot(planAttributes, aes(x = planAttributes$moop)) + geom_histogram()


```


# Analyse: Beträge der Deckungskosten der Mitversicherung für das Muster-SBC-Szenario von Diabetes
```{r, echo=FALSE}
library(ggplot2) 
library(readr) 
library(dplyr)
library(RColorBrewer)
library(DT)
library(choroplethrMaps)
library(choroplethr)


##Setwd for omar besic 
setwd("C:/Users/omarb/Desktop/Studium/6. Semester/06_Business Intelligence im Spital/Projekt/bi_project")

##Setwd for musab elkour 
# setwd("C:/dev/bi_project")

#import data with help of the readr package and reads comma delimited files
hc <- read.csv("PlanAttributes.csv", stringsAsFactors = FALSE)


# replace all "," with " " AND all "\\$" with " " in SBCHavingDiabetesCoinsurance
hc$SBCHavingDiabetesCoinsurance<- gsub('\\$', '', hc$SBCHavingDiabetesCoinsurance)
hc$SBCHavingDiabetesCoinsurance<- gsub(',', '', hc$SBCHavingDiabetesCoinsurance)
# assign (and convert to numeric) the column of SBCHavingDiabetesCoinsurance
hc$coinsurance <- as.numeric(hc$SBCHavingDiabetesCoinsurance)
# fill the blank cells with 0
hc$coinsurance[is.na(hc$coinsurance)] <- 0



counts <- table(hc$coinsurance)
#barplot of coinsurance
barplot(counts, main="The coinsurance for the sample SBC scenario of having diabetes",
        xlab="Dollar Amount", ylab="Counts")

# plot histogram of coinsurance dollar amount (x axis) and count in (y axis)
ggplot(hc, aes(x = hc$coinsurance)) + geom_histogram(color="green")


#list aggregation of the mean of the coinsurance with the statecode and print it 
df <- aggregate(hc$coinsurance, list(hc$StateCode), mean)
df

#Set the title of the printed aggregated list above with new labels and print it 
names(df) <- c("state", "coinsurance")
df




#----------------- geograph --------
library(tigris)
library(leaflet)
library(geojson)

#In this case, we will use the geojsonio package to load the data into sp objects, which will let us easily manipulate the geographic features, and their properties, in R.
# transfrom .json file into a spatial polygons data frame
states <- geojsonio::geojson_read(x = "https://raw.githubusercontent.com/PublicaMundi/MappingAPI/master/data/geojson/us-states.json"
                                  , what = "sp")
class(states)
names(states)

#a basic map with just the outline of the states
m <- leaflet(states) %>%
  setView(-96, 37.8, 4) %>%
  addProviderTiles("MapBox", options = providerTileOptions(
    id = "mapbox.light",
    accessToken = Sys.getenv('MAPBOX_ACCESS_TOKEN')))

#We’ve saved the basic basemap as a separate variable m so we can easily iterate on the addPolygons call 
#call addPolygons with no additional arguments -- To add uniform polygons with default styling
m %>% addPolygons()

#First, we’ll define the bins. This is a numeric vector that defines the boundaries between intervals 
bins <- c(0, 10, 20, 50, 100, 200, 500, 1000, Inf)

#Then, we’ll call colorBin to generate a palette function that maps the RColorBrewer "YlOrRd" colors to our bins.
pal <- colorBin("YlOrRd", domain = states$density, bins = bins)


#Adding Color to the map 
#Finally, we’ll modify addPolygons to use the palette function and the density values to generate a vector of colors for fillColor, and also add some other static style properties.
m %>% addPolygons(
  fillColor = ~pal(density),
  weight = 2,
  opacity = 1,
  color = "white",
  dashArray = "3",
  fillOpacity = 0.7)

#Adding interaction 
#make the polygons highlight as the mouse passes over them. The addPolygon function has a highlight argument that makes this simple
m %>% addPolygons(
  fillColor = ~pal(density),
  weight = 2,
  opacity = 1,
  color = "white",
  dashArray = "3",
  fillOpacity = 0.7,
  highlight = highlightOptions(
    weight = 5,
    color = "#666",
    dashArray = "",
    fillOpacity = 0.7,
    bringToFront = TRUE))


#Custom infos 
#We’ll generate the labels by handcrafting some HTML, and passing it to lapply(htmltools::HTML) so that Leaflet knows to treat each label as HTML instead of as plain text. We’ll also set some label options to improve the style of the label element itself.
labels <- sprintf(
  "<strong>%s</strong><br/>%g people / mi<sup>2</sup> <br/> coinsurance 2014",
  states$name, states$density
  )  %>% lapply(htmltools::HTML)

m <- m %>% addPolygons(
  fillColor = ~pal(density),
  weight = 2,
  opacity = 1,
  color = "white",
  dashArray = "3",
  fillOpacity = 0.7,
  highlight = highlightOptions(
    weight = 5,
    color = "#666",
    dashArray = "",
    fillOpacity = 0.7,
    bringToFront = TRUE),
  label = labels,
  labelOptions = labelOptions(
    style = list("font-weight" = "normal", padding = "3px 8px"),
    textsize = "15px",
    direction = "auto"))
m


#add a legend. Because we chose to color our map using colorBin, the addLegend function makes it particularly easy to add a legend with the correct colors and intervals.
m %>% addLegend(pal = pal, values = ~pal(density), opacity = 0.7, title = "amount of dollar",
               position = "bottomright")

```


<<<<<<< Updated upstream
library(ggplot2)
library(readr)
library(dplyr)
library(extrafont)
library(choroplethr)
library(extrafontdb)
library(RColorBrewer)
library(scales)
library(gridExtra)
library(choroplethrMaps)
library(formattable)
library(knitr)
library(kableExtra)
##Setwd for omar besic
setwd("C:/Users/omarb/Desktop/Studium/6. Semester/06_Business Intelligence im Spital/Projekt/bi_project")
# import data with help of the readr package and reads comma delimited files
planAttributes <- read.csv("PlanAttributes.csv", stringsAsFactors = FALSE)
names(planAttributes) %>%
kable() %>%
kable_styling()
names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover"))
names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), fixed_header = list(enabled = T, background = "red"))
names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive", fixed_header = list(enabled = T, background = "red")))
names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
overviewColumns <- names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
overviewColumns <- fixed_header = list(enabled = T, background = "red")
names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), fixed_thead = list(enabled = T/F, background = "blue"))
names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), fixed_thead = list(enabled = T, background = "blue"))
names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), fixed_thead = list(enabled = F, background = "blue"))
names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), fixed_thead = list(enabled = T, background = "blue"))
names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "blue")
, stripe_color("blue")
)
names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow")
)
names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "blue", "responsive")
, fixed_thead = list(enabled = T, background = "yellow")
)
names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = T
)
names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow")
)
names(planAttributes) %>%
names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow"))
names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow"))
allColumns <- names(planAttributes)
knitr::opts_chunk$set(echo = TRUE)
names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow"))
names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow"))  %>%
row_spec(121,159, bold = T, color = "white", background = "#D7261E")
names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow"))  %>%
row_spec(121;159, bold = T, color = "white", background = "#D7261E")
names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow"))  %>%
row_spec(121 && 159, bold = T, color = "white", background = "#D7261E")
names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow"))  %>%
row_spec(121, bold = T, color = "white", background = "#D7261E")
names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow"))  %>%
row_spec(cbind(121,159), bold = T, color = "white", background = "#D7261E")
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(readr)
library(dplyr)
library(choroplethr)
library(extrafont)
library(extrafontdb)
library(RColorBrewer)
library(scales)
library(gridExtra)
library(choroplethrMaps)
library(knitr)
library(kableExtra)
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(readr)
library(dplyr)
library(choroplethr)
library(extrafont)
library(extrafontdb)
library(RColorBrewer)
library(scales)
library(gridExtra)
library(choroplethrMaps)
library(knitr)
library(kableExtra)
names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow"))  %>%
row_spec(cbind(121,159), bold = T, color = "white", background = "#D7261E")
planAttributes <- read.csv("PlanAttributes.csv", stringsAsFactors = FALSE)
names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow"))  %>%
row_spec(cbind(121,159), bold = T, color = "white", background = "#D7261E")
##Setwd for omar besic
setwd("C:/Users/omarb/Desktop/Studium/6. Semester/06_Business Intelligence im Spital/Projekt/bi_project")
=======
dashArray = "",
fillOpacity = 0.7,
bringToFront = TRUE))
#Custom infos
#We'll generate the labels by handcrafting some HTML, and passing it to lapply(htmltools::HTML) so that Leaflet knows to treat each label as HTML instead of as plain text. We'll also set some label options to improve the style of the label element itself.
labels <- sprintf(
paste0("<strong>", states$name,
"<br /> Businessyear: ", pa$BusinessYear
)
)  %>% lapply(htmltools::HTML)
xmap <- map %>% addPolygons(
fillColor = ~pal(pa$coinsurance),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7,
highlight = highlightOptions(
weight = 5,
color = "#666",
dashArray = "",
fillOpacity = 0.7,
bringToFront = TRUE),
label = labels,
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"))
#illustrate the map with this line
map
#add a legend. Because we chose to color our map using colorBin, the addLegend function makes it particularly easy to add a legend with the correct colors and intervals.
m %>% addLegend(pal = pal, values = ~pal(pa$coinsurance), opacity = 0.7, title = "amount of dollar",
position = "bottomright")
class(states)
names(states)
#a basic map with just the outline of the states
map <- leaflet(pa$StateCode) %>%
setView(-96, 37.8, 4) %>%
addProviderTiles("MapBox", options = providerTileOptions(
id = "mapbox.light",
accessToken = Sys.getenv('MAPBOX_ACCESS_TOKEN')))
#We've saved the basic basemap as a separate variable m so we can easily iterate on the addPolygons call
#call addPolygons with no additional arguments -- To add uniform polygons with default styling
map %>% addPolygons()
class(pa$StateCode)
#a basic map with just the outline of the states
map <- leaflet(pa$StateCode) %>%
setView(-96, 37.8, 4) %>%
addProviderTiles("MapBox", options = providerTileOptions(
id = "mapbox.light",
accessToken = Sys.getenv('MAPBOX_ACCESS_TOKEN')))
#We've saved the basic basemap as a separate variable m so we can easily iterate on the addPolygons call
#call addPolygons with no additional arguments -- To add uniform polygons with default styling
map %>% addPolygons()
class(states)
names(states)
#a basic map with just the outline of the states
map <- leaflet(states) %>%
setView(-96, 37.8, 4) %>%
addProviderTiles("MapBox", options = providerTileOptions(
id = "mapbox.light",
accessToken = Sys.getenv('MAPBOX_ACCESS_TOKEN')))
#We've saved the basic basemap as a separate variable m so we can easily iterate on the addPolygons call
#call addPolygons with no additional arguments -- To add uniform polygons with default styling
map %>% addPolygons()
#First, we'll define the bins. This is a numeric vector that defines the boundaries between intervals
bins <- c(0, 10, 20, 50, 100, 200, 500, 1000, Inf)
#Then, we'll call colorBin to generate a palette function that maps the RColorBrewer "YlOrRd" colors to our bins.
pal <- colorBin("YlGnBu", domain = pa$coinsurance, bins = bins)
#Adding Color to the map
#Finally, we'll modify addPolygons to use the palette function to generate a vector of colors for fillColor, and also add some other static style properties.
map %>% addPolygons(
fillColor = ~pal(pa$coinsurance),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7)
#Adding interaction
#make the polygons highlight as the mouse passes over them. The addPolygon function has a highlight argument that makes this simple
map %>% addPolygons(
fillColor = ~pal(pa$coinsurance),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7,
highlight = highlightOptions(
weight = 5,
color = "#666",
dashArray = "",
fillOpacity = 0.7,
bringToFront = TRUE))
#Custom infos
#We'll generate the labels by handcrafting some HTML, and passing it to lapply(htmltools::HTML) so that Leaflet knows to treat each label as HTML instead of as plain text. We'll also set some label options to improve the style of the label element itself.
labels <- sprintf(
paste0("<strong>", states$name,
"<br /> Businessyear: ", pa$BusinessYear
)
)  %>% lapply(htmltools::HTML)
xmap <- map %>% addPolygons(
fillColor = ~pal(pa$coinsurance),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7,
highlight = highlightOptions(
weight = 5,
color = "#666",
dashArray = "",
fillOpacity = 0.7,
bringToFront = TRUE),
label = labels,
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"))
#illustrate the map with this line
map
#add a legend. Because we chose to color our map using colorBin, the addLegend function makes it particularly easy to add a legend with the correct colors and intervals.
m %>% addLegend(pal = pal, values = ~pal(pa$coinsurance), opacity = 0.7, title = "amount of dollar",
position = "bottomright")
#Custom infos
#We'll generate the labels by handcrafting some HTML, and passing it to lapply(htmltools::HTML) so that Leaflet knows to treat each label as HTML instead of as plain text. We'll also set some label options to improve the style of the label element itself.
labels <- sprintf(
paste0(
"<br /> Businessyear: ", pa$BusinessYear
)
)  %>% lapply(htmltools::HTML)
xmap <- map %>% addPolygons(
fillColor = ~pal(pa$coinsurance),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7,
highlight = highlightOptions(
weight = 5,
color = "#666",
dashArray = "",
fillOpacity = 0.7,
bringToFront = TRUE),
label = labels,
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"))
#illustrate the map with this line
map
#add a legend. Because we chose to color our map using colorBin, the addLegend function makes it particularly easy to add a legend with the correct colors and intervals.
m %>% addLegend(pal = pal, values = ~pal(pa$coinsurance), opacity = 0.7, title = "amount of dollar",
position = "bottomright")
#Custom infos
#We'll generate the labels by handcrafting some HTML, and passing it to lapply(htmltools::HTML) so that Leaflet knows to treat each label as HTML instead of as plain text. We'll also set some label options to improve the style of the label element itself.
labels <- sprintf(
)  %>% lapply(htmltools::HTML)
#Custom infos
#We'll generate the labels by handcrafting some HTML, and passing it to lapply(htmltools::HTML) so that Leaflet knows to treat each label as HTML instead of as plain text. We'll also set some label options to improve the style of the label element itself.
labels <- sprintf(""
)  %>% lapply(htmltools::HTML)
xmap <- map %>% addPolygons(
fillColor = ~pal(pa$coinsurance),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7,
highlight = highlightOptions(
weight = 5,
color = "#666",
dashArray = "",
fillOpacity = 0.7,
bringToFront = TRUE),
label = labels,
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"))
#illustrate the map with this line
map
#add a legend. Because we chose to color our map using colorBin, the addLegend function makes it particularly easy to add a legend with the correct colors and intervals.
m %>% addLegend(pal = pal, values = ~pal(pa$coinsurance), opacity = 0.7, title = "amount of dollar",
position = "bottomright")
xmap <- map %>% addPolygons(
fillColor = ~pal(pa$coinsurance),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7,
highlight = highlightOptions(
weight = 5,
color = "#555",
dashArray = "",
fillOpacity = 0.7,
bringToFront = TRUE),
label = labels,
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"))
#illustrate the map with this line
map
xmap <- map %>% addPolygons(
fillColor = ~pal(pa$coinsurance),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7,
highlight = highlightOptions(
weight = 5,
color = "red",
dashArray = "",
fillOpacity = 0.7,
bringToFront = TRUE),
label = labels,
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"))
#illustrate the map with this line
map
xmap <- map %>% addPolygons(
fillColor = ~pal(pa$coinsurance),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7,
highlight = highlightOptions(
weight = 5,
color = "#666",
dashArray = "",
fillOpacity = 0.7,
bringToFront = TRUE),
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"))
#illustrate the map with this line
map
#Custom infos
#We'll generate the labels by handcrafting some HTML, and passing it to lapply(htmltools::HTML) so that Leaflet knows to treat each label as HTML instead of as plain text. We'll also set some label options to improve the style of the label element itself.
labels <- sprintf(
paste0("<strong>", states$name,
"<br /> Businessyear: ", pa$BusinessYear
)
)  %>% lapply(htmltools::HTML)
xmap <- map %>% addPolygons(
fillColor = ~pal(pa$coinsurance),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7,
highlight = highlightOptions(
weight = 5,
color = "#666",
dashArray = "",
fillOpacity = 0.7,
bringToFront = TRUE),
label = labels,
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"))
#illustrate the map with this line
map
#add a legend. Because we chose to color our map using colorBin, the addLegend function makes it particularly easy to add a legend with the correct colors and intervals.
m %>% addLegend(pal = pal, values = ~pal(pa$coinsurance), opacity = 0.7, title = "amount of dollar",
position = "bottomright")
>>>>>>> Stashed changes
library(ggplot2)
library(readr)
library(dplyr)
library(RColorBrewer)
library(DT)
library(choroplethrMaps)
library(choroplethr)
##Setwd for omar besic
<<<<<<< Updated upstream
setwd("C:/Users/omarb/Desktop/Studium/6. Semester/06_Business Intelligence im Spital/Projekt/bi_project")
##Setwd for musab elkour
# setwd("C:/dev/bi_project")
#import data with help of the readr package and reads comma delimited files
hc <- read.csv("PlanAttributes.csv", stringsAsFactors = FALSE)
# replace all "," with " " AND all "\\$" with " " in SBCHavingDiabetesCoinsurance
hc$SBCHavingDiabetesCoinsurance<- gsub('\\$', '', hc$SBCHavingDiabetesCoinsurance)
hc$SBCHavingDiabetesCoinsurance<- gsub(',', '', hc$SBCHavingDiabetesCoinsurance)
# assign (and convert to numeric) the column of SBCHavingDiabetesCoinsurance
hc$coinsurance <- as.numeric(hc$SBCHavingDiabetesCoinsurance)
# fill the blank cells with 0
hc$coinsurance[is.na(hc$coinsurance)] <- 0
counts <- table(hc$coinsurance)
#barplot of coinsurance
barplot(counts, main="The coinsurance for the sample SBC scenario of having diabetes",
xlab="Dollar Amount", ylab="Counts")
# plot histogram of coinsurance dollar amount (x axis) and count in (y axis)
ggplot(hc, aes(x = hc$coinsurance)) + geom_histogram(color="green")
#list aggregation of the mean of the coinsurance with the statecode and print it
df <- aggregate(hc$coinsurance, list(hc$StateCode), mean)
=======
##setwd("C:/Users/omarb/Desktop/Studium/6. Semester/
##      06_Business Intelligence im Spital/Projekt/bi_project")
##Setwd for musab elkour
setwd("C:/dev/bi_project")
#import data with help of the readr package and reads comma delimited files
pa <- read.csv("PlanAttributes.csv", stringsAsFactors = FALSE)
#prints all the data in the columns which are in the business year 2014
#Just for checking the access to the data
#subset and filter the data just for the buisness year 2014
pa <- subset(pa, BusinessYear == "2014")
print(subset(pa, BusinessYear == "2014"))
#A quick glimpse and then some data cleaning of SBCHavingDiabetesCoinsurance (The dollar amount of the coinsurance for the sample SBC scenario of having diabetes)
#Coinsurance = Eine Mitversicherung ist die Beteiligung mehrerer Versicherungsunternehmen an der Versicherung desselben Risikos
#SBC= Summary of Benefits and Coverage Provides Clear and Consistent Information == allowing employers and employees to make apples-to-apples comparisons among plans, understand what is covered and what it costs
head(pa$SBCHavingDiabetesCoinsurance, 100)
# replace all "," with " " AND all "\\$" with " " in SBCHavingDiabetesCoinsurance
pa$SBCHavingDiabetesCoinsurance<- gsub('\\$', '', pa$SBCHavingDiabetesCoinsurance)
pa$SBCHavingDiabetesCoinsurance<- gsub(',', '', pa$SBCHavingDiabetesCoinsurance)
# assign (and convert to numeric) the column of SBCHavingDiabetesCoinsurance
pa$coinsurance <- as.numeric(pa$SBCHavingDiabetesCoinsurance)
# fill the blank cells with 0
pa$coinsurance[is.na(pa$coinsurance)] <- 0
head(pa$coinsurance, 100)
#subset and filter all coinsurances which equals 0 (remove all 0 values)
pa <- subset(pa, coinsurance != 0)
##set data of coinsurance in a table for the barplot
counts <- table(pa$coinsurance)
#barplot of coinsurance
barplot(counts, main="Deckungskosten der Mitversicherung für Diabeteserkrankte in 2014",
xlab="Dollar Amount", ylab="Counts", col="green")
# plot histogram of coinsurance dollar amount (x axis) and count in (y axis)
ggplot(pa, aes(x = pa$coinsurance)) + geom_histogram(col="black", fill="green")
#list aggregation of the mean of the coinsurance with the statecode and print it
df <- aggregate(pa$coinsurance, list(pa$StateCode), mean)
>>>>>>> Stashed changes
df
#Set the title of the printed aggregated list above with new labels and print it
names(df) <- c("state", "coinsurance")
df
<<<<<<< Updated upstream
=======
# converts states abbreviations
source("function_stateFromLower.R")
#calling the states from the function stateFromLower
df$region<-stateFromLower(df$Group1)
df$value <- df$overall
#get summary of the states, coinsurance and region (Length, Median, mean...)
summary(df)
#Subset of all the coinsurances above 0
coinsurance <- subset(pa, coinsurance > 0)
#------------------------choro Map creation -------------------------------------
#Aggregate the coinsurance with statecodes
df <- aggregate(pa$coinsurance, list(pa$StateCode), mean)
#calling the states from the function stateFromLower
# Group.i for by[[i]]. -> in this case first group "Group.1" is group of all states
df$region<-stateFromLower(df$Group.1)
df$value <- df$x
#generate new choro object
choro = StateChoropleth$new(df)
# set title to the new choro map
choro$title = "    Deckungskosten der Mitversicherung für Diabeteserkrankte in 2014"
# The number of colors to use on the map. A value of 0 uses a divergent scale
choro$set_num_colors(1)
# These functions are useful for converting hand-designed `sequential' or `diverging' color
# here green levels set
myPalette <- colorRampPalette(brewer.pal(9, "Blues"))
#fill value and border color
choro$ggplot_polygon = geom_polygon(aes(fill = value), color = "black")
#legend
choro$ggplot_scale = scale_fill_gradientn(name = "Dollar amount", colours = myPalette(9))
#show and visualizie the choro map
choro$render()
#------------------------- END choro Map Functions ------------------------------------------------
#subset the data for reasons that will become clear. Here use the 2014 and 2015 data.
#to check if the coinsurance has gotten higher or not
coinsurance <- subset(coinsurance, BusinessYear == "2014")
dim(coinsurance)
coinsurance <- subset(coinsurance, BusinessYear == "2015")
dim(coinsurance)
>>>>>>> Stashed changes
#----------------- geograph --------
library(tigris)
library(leaflet)
library(geojson)
#In this case, we will use the geojsonio package to load the data into sp objects, which will let us easily manipulate the geographic features, and their properties, in R.
# transfrom .json file into a spatial polygons data frame
states <- geojsonio::geojson_read(x = "https://raw.githubusercontent.com/PublicaMundi/MappingAPI/master/data/geojson/us-states.json"
, what = "sp")
class(states)
names(states)
#a basic map with just the outline of the states
<<<<<<< Updated upstream
m <- leaflet(states) %>%
=======
map <- leaflet(states) %>%
>>>>>>> Stashed changes
setView(-96, 37.8, 4) %>%
addProviderTiles("MapBox", options = providerTileOptions(
id = "mapbox.light",
accessToken = Sys.getenv('MAPBOX_ACCESS_TOKEN')))
<<<<<<< Updated upstream
#We’ve saved the basic basemap as a separate variable m so we can easily iterate on the addPolygons call
#call addPolygons with no additional arguments -- To add uniform polygons with default styling
m %>% addPolygons()
#First, we’ll define the bins. This is a numeric vector that defines the boundaries between intervals
bins <- c(0, 10, 20, 50, 100, 200, 500, 1000, Inf)
#Then, we’ll call colorBin to generate a palette function that maps the RColorBrewer "YlOrRd" colors to our bins.
pal <- colorBin("YlOrRd", domain = states$density, bins = bins)
#Adding Color to the map
#Finally, we’ll modify addPolygons to use the palette function and the density values to generate a vector of colors for fillColor, and also add some other static style properties.
m %>% addPolygons(
fillColor = ~pal(density),
=======
#We've saved the basic basemap as a separate variable m so we can easily iterate on the addPolygons call
#call addPolygons with no additional arguments -- To add uniform polygons with default styling
map %>% addPolygons()
#First, we'll define the bins. This is a numeric vector that defines the boundaries between intervals
bins <- c(0, 10, 20, 50, 100, 200, 500, 1000, Inf)
#Then, we'll call colorBin to generate a palette function that maps the RColorBrewer "YlOrRd" colors to our bins.
pal <- colorBin("YlGnBu", domain = pa$coinsurance, bins = bins)
#Adding Color to the map
#Finally, we'll modify addPolygons to use the palette function to generate a vector of colors for fillColor, and also add some other static style properties.
map %>% addPolygons(
fillColor = ~pal(pa$coinsurance),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7)
#Adding interaction
#make the polygons highlight as the mouse passes over them. The addPolygon function has a highlight argument that makes this simple
map %>% addPolygons(
fillColor = ~pal(pa$coinsurance),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7,
highlight = highlightOptions(
weight = 5,
color = "#666",
dashArray = "",
fillOpacity = 0.7,
bringToFront = TRUE))
#Custom infos
#We'll generate the labels by handcrafting some HTML, and passing it to lapply(htmltools::HTML) so that Leaflet knows to treat each label as HTML instead of as plain text. We'll also set some label options to improve the style of the label element itself.
labels <- sprintf(
paste0("<strong>", states$name,
"<br /> Businessyear: ", pa$BusinessYear
)
)  %>% lapply(htmltools::HTML)
xmap <- map %>% addPolygons(
fillColor = ~pal(pa$coinsurance),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7,
highlight = highlightOptions(
weight = 5,
color = "#666",
dashArray = "",
fillOpacity = 0.7,
bringToFront = TRUE),
label = labels,
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"))
#illustrate the map with this line
map
#add a legend. Because we chose to color our map using colorBin, the addLegend function makes it particularly easy to add a legend with the correct colors and intervals.
m %>% addLegend(pal = pal, values = ~pal(pa$coinsurance), opacity = 0.7, title = "amount of dollar",
position = "bottomright")
#Custom infos
#We'll generate the labels by handcrafting some HTML, and passing it to lapply(htmltools::HTML) so that Leaflet knows to treat each label as HTML instead of as plain text. We'll also set some label options to improve the style of the label element itself.
labels <- sprintf(
paste0("<strong>", states$name         )
)  %>% lapply(htmltools::HTML)
xmap <- map %>% addPolygons(
fillColor = ~pal(pa$coinsurance),
>>>>>>> Stashed changes
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
<<<<<<< Updated upstream
fillOpacity = 0.7)
#Adding interaction
#make the polygons highlight as the mouse passes over them. The addPolygon function has a highlight argument that makes this simple
m %>% addPolygons(
fillColor = ~pal(density),
=======
fillOpacity = 0.7,
highlight = highlightOptions(
weight = 5,
color = "#666",
dashArray = "",
fillOpacity = 0.7,
bringToFront = TRUE),
label = labels,
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"))
#illustrate the map with this line
map
#Custom infos
#We'll generate the labels by handcrafting some HTML, and passing it to lapply(htmltools::HTML) so that Leaflet knows to treat each label as HTML instead of as plain text. We'll also set some label options to improve the style of the label element itself.
labels <- sprintf(
"<br /> Businessyear: ", pa$BusinessYear
)  %>% lapply(htmltools::HTML)
xmap <- map %>% addPolygons(
fillColor = ~pal(pa$coinsurance),
>>>>>>> Stashed changes
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7,
highlight = highlightOptions(
weight = 5,
color = "#666",
dashArray = "",
fillOpacity = 0.7,
<<<<<<< Updated upstream
bringToFront = TRUE))
=======
bringToFront = TRUE),
label = labels,
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"))
#illustrate the map with this line
map
>>>>>>> Stashed changes
#Custom infos
#We'll generate the labels by handcrafting some HTML, and passing it to lapply(htmltools::HTML) so that Leaflet knows to treat each label as HTML instead of as plain text. We'll also set some label options to improve the style of the label element itself.
labels <- sprintf(
<<<<<<< Updated upstream
"<strong>%s</strong><br/>%g people / mi<sup>2</sup> <br/> coinsurance 2014",
states$name, states$density
=======
"<br /> Businessyear: ", pa$BusinessYear
>>>>>>> Stashed changes
)  %>% lapply(htmltools::HTML)
xmap <- map %>% addPolygons(
fillColor = ~pal(pa$coinsurance),
weight = 2,
opacity = 1,
color = "white",
dashArray = "3",
fillOpacity = 0.7,
highlight = highlightOptions(
weight = 5,
color = "#666",
dashArray = "",
fillOpacity = 0.7,
bringToFront = TRUE),
label = labels,
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"))
<<<<<<< Updated upstream
m
#add a legend. Because we chose to color our map using colorBin, the addLegend function makes it particularly easy to add a legend with the correct colors and intervals.
m %>% addLegend(pal = pal, values = ~pal(density), opacity = 0.7, title = "amount of dollar",
position = "bottomright")
planAttributes[121:159]
selectedRows <- planAttributes[121:159]
names(selectedRows) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow"))  %>%
row_spec(cbind(121,159), bold = T, color = "white", background = "#D7261E")
names(planAttributes[121:159]) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow"))  %>%
row_spec(cbind(121,159), bold = T, color = "white", background = "#D7261E")
planAttributes <- as_tibble(planAttributes)
planAttributesColumns %>% pull(121:159)
planAttributesColumns <- as_tibble(planAttributes)
planAttributesColumns %>% pull(121:159)
planAttributesColumns <- as_tibble(planAttributes)
planAttributesColumns %>% pull(SBCHavingDiabetesCoinsurance)
planAttributesColumns %>% pull(SBCHavingDiabetesCoinsurance:SBCHavingDiabetesCopayment)
planAttributes <- read.csv("PlanAttributes.csv", stringsAsFactors = FALSE)
planAttributes <- read.csv("PlanAttributes.csv", stringsAsFactors = FALSE)
names(planAttributes) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow"))  %>%
row_spec(cbind(121,159), bold = T, color = "white", background = "#D7261E")
planAttributesColumns <- as_tibble(planAttributes)
planAttributesColumns <- planAttributesColumns %>% select(121:159)
names(planAttributesColumns) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow"))  %>%
row_spec(cbind(121,159), bold = T, color = "white", background = "#D7261E")
planAttributes <- read.csv("PlanAttributes.csv", stringsAsFactors = FALSE)
planAttributesColumns <- as_tibble(planAttributes)
planAttributesColumns <- planAttributesColumns %>% select(121:159)
names(planAttributesColumns) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow"))  %>%
row_spec(cbind(1,2), bold = T, color = "white", background = "#D7261E")
planAttributes <- read.csv("PlanAttributes.csv", stringsAsFactors = FALSE)
planAttributesColumns <- as_tibble(planAttributes)
planAttributesColumns <- planAttributesColumns %>% select(100:180)
planAttributesColumns <- as_tibble(planAttributes)
planAttributesColumns <- planAttributesColumns %>% select(121:159)
planAttributes <- read.csv("PlanAttributes.csv", stringsAsFactors = FALSE)
planAttributesColumns <- as_tibble(planAttributes)
planAttributesColumns <- planAttributesColumns %>% select(100:170)
names(planAttributesColumns) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow"))  %>%
row_spec(cbind(1,121), bold = T, color = "white", background = "#D7261E")
planAttributes <- read.csv("PlanAttributes.csv", stringsAsFactors = FALSE)
planAttributesColumns <- as_tibble(planAttributes)
planAttributesColumns <- planAttributesColumns %>% select(100:170)
names(planAttributesColumns) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow"))  %>%
row_spec(cbind(1,70), bold = T, color = "white", background = "#D7261E")
planAttributesColumns <- as_tibble(planAttributes)
planAttributesColumns <- planAttributesColumns %>% select(100:110 && 160:170)
planAttributesColumns <- planAttributesColumns %>% select(100:110,160:170)
names(planAttributesColumns) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow"))  %>%
row_spec(cbind(1,70), bold = T, color = "white", background = "#D7261E")
names(planAttributesColumns) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow"))  %>%
row_spec(cbind(1,20), bold = T, color = "white", background = "#D7261E")
planAttributesColumns <- as_tibble(planAttributes)
names(planAttributesColumns) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow"))  %>%
row_spec(cbind(1,25), bold = T, color = "white", background = "#D7261E")
planAttributes <- read.csv("PlanAttributes.csv", stringsAsFactors = FALSE)
planAttributesColumns <- as_tibble(planAttributes)
planAttributesColumns <- planAttributesColumns %>% select(95:110,160:170)
names(planAttributesColumns) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow"))  %>%
row_spec(cbind(1,25), bold = T, color = "white", background = "#D7261E")
planAttributesColumns <- as_tibble(planAttributes)
planAttributesColumns <- planAttributesColumns %>% select(110:130,150:165)
names(planAttributesColumns) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow"))  %>%
row_spec(cbind(1,25), bold = T, color = "white", background = "#D7261E")
planAttributes <- read.csv("PlanAttributes.csv", stringsAsFactors = FALSE)
planAttributesColumns <- as_tibble(planAttributes)
planAttributesColumns <- planAttributesColumns %>% select(110:130,150:165)
names(planAttributesColumns) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow"))  %>%
row_spec(cbind(11,29), bold = T, color = "white", background = "#D7261E")
planAttributes <- read.csv("PlanAttributes.csv", stringsAsFactors = FALSE)
planAttributesColumns <- as_tibble(planAttributes)
planAttributesColumns <- planAttributesColumns %>% select(110:130,150:165)
names(planAttributesColumns) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "yellow"))  %>%
row_spec(cbind(12,31), bold = T, color = "white", background = "#D7261E")
names(planAttributesColumns) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "dark"))  %>%
row_spec(cbind(12,31), bold = T, color = "white", background = "#D7261E")
planAttributes <- read.csv("PlanAttributes.csv", stringsAsFactors = FALSE)
planAttributesColumns <- as_tibble(planAttributes)
planAttributesColumns
planAttributesColumns <- planAttributesColumns %>% select(110:130,150:165)
names(planAttributesColumns) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "dark"))  %>%
row_spec(cbind(12,31), bold = T, color = "white", background = "#D7261E")
planAttributes <- read.csv("PlanAttributes.csv", stringsAsFactors = FALSE)
planAttributesColumns <- as_tibble(planAttributes)
planAttributesColumns <- planAttributesColumns %>% select(110:130,150:165)
names(planAttributesColumns) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")
, fixed_thead = list(enabled = T, background = "dark"))  %>%
row_spec(cbind(12,31), bold = T, color = "white", background = "#D7261E")
=======
#illustrate the map with this line
map
#add a legend. Because we chose to color our map using colorBin, the addLegend function makes it particularly easy to add a legend with the correct colors and intervals.
m %>% addLegend(pal = pal, values = ~pal(pa$coinsurance), opacity = 0.7, title = "amount of dollar",
position = "bottomright")
>>>>>>> Stashed changes
